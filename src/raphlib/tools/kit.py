
from typing import List, Dict, Tuple, Any, Callable, Optional, Iterator, AsyncIterator
import pydantic, asyncio, inspect

from .tool import BaseTool, ToolMessage, ToolCall

def create_model(name: str, signature: inspect.Signature) -> pydantic.BaseModel:
    """Create a Pydantic model from a function signature."""
    fields: Dict[str, Tuple[type, ellipsis]] = {}
    for param in signature.parameters.values():
        if param.annotation is inspect.Parameter.empty:
            raise ValueError(f"Parameter {param.name} has no type annotation")
        else:
            fields[param.name] = (param.annotation, ...)
    return pydantic.create_model(name, **fields)

class ToolKit(pydantic.BaseModel):
    """
    A collection of tools for a LLM.
    """
    tools: Dict[str, BaseTool] = {}
    
    def __getitem__(self, key: str, default: Any = None) -> BaseTool:
        return self.tools.get(key, default)

    def __setitem__(self, key: str, value: BaseTool) -> None:
        self.tools[key] = value
        
    def __in__(self, reference: BaseTool) -> bool:
        return reference in self.tools.values()
    
    def __iter__(self):
        return iter(self.tools.values())
    
    def __call__(self, calls: List[ToolCall]) -> List[ToolMessage]:
        return self.run(calls)
            
    def run(self, calls: List[ToolCall]) -> List[ToolMessage]:
        return [self.tools[call["name"]].run(call) for call in calls]
    
    async def arun(self, calls: List[ToolCall]) -> List[ToolMessage]:
        results = await asyncio.gather(
            *[self.tools[call["name"]].arun(call) for call in calls]
        )
        return results
        
    def tool(self, f: Callable) -> BaseTool:
        """
        Decorator to convert a function into a BaseTool instance and **bind** it to the current ToolKit.
        The tool can be extracted from the ToolKit by calling get.

        The decorated function can be synchronous, asynchronous, or a generator.
        When using generators, each yielded value produces a streamed event, and the final value
        is displayed to the LLM. Raises ValueError if the function signature is invalid.

        ## Example:
        
            @tool
            def func(inp: InputModel):
                return f"The input was {inp.parameter}"
        """
        # Inspect the function signature to ensure it has zero or one parameter.
        sig = inspect.signature(f)
        if sig.parameters:
            input_model = create_model(f.__name__, sig)
        else:
            input_model = None
        
        # Determine the function type (sync/async, generator, etc.)
        is_async = asyncio.iscoroutinefunction(f)
        is_gen = inspect.isgeneratorfunction(f)
        is_asyncgen = inspect.isasyncgenfunction(f)
        
        # Dynamically create a BaseTool subclass that wraps f.
        class ToolWrapper(BaseTool):
            name: str = f.__name__
            description: str = f.__doc__ or (
                f"This tool was autogenerated by a decorated function. No docstring was included "
                f"in the original function, therefore this tool has no description. Please warn the developer "
                f"that function \"{f.__name__}\" needs a docstring."
            )
            args_schema: type = input_model
                    
            if is_asyncgen:
                async def _astream(self, inp: Optional[pydantic.BaseModel] = None) -> AsyncIterator[str]:
                    stream = f(**inp.model_dump()) if inp else f()
                    async for item in stream:
                        yield str(item)

            elif is_gen:
                def _stream(self, inp: Optional[pydantic.BaseModel] = None) -> Iterator[str]:
                    stream = f(**inp.model_dump()) if inp else f()
                    for item in stream:
                        yield str(item)

            elif is_async:
                async def _arun(self, inp: Optional[pydantic.BaseModel] = None) -> str:
                    coro = f(**inp.model_dump()) if inp else f()
                    result = await coro
                    return str(result)

            else:
                def _run(self, inp: Optional[pydantic.BaseModel] = None) -> str:
                    result = f(**inp.model_dump()) if inp else f()
                    return str(result)
        
        # Bind to tool kit and return as a BaseTool instance.
        self.tools[f.__name__] = ToolWrapper()
        
        return self.tools[f.__name__]
