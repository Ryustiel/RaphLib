
from typing import List, Dict, Any, Callable, Optional, Iterator, AsyncIterator
import pydantic, asyncio, inspect

from .tool import BaseTool, ToolMessage, ToolCall

class ToolKit(pydantic.BaseModel):
    """
    A collection of tools for a LLM.
    """
    
    tools: Dict[str, BaseTool] = {}
    
    def __getitem__(self, key: str, default: Any = None) -> BaseTool:
        return self.tools.get(key, default)

    def __setitem__(self, key: str, value: BaseTool) -> None:
        self.tools[key] = value
        
    def __in__(self, reference: Any):
        return reference in self.tools.values()
    
    def itertools(self) -> Iterator[BaseTool]:
        """
        Iterate over the tools in the toolkit.
        """
        for tool in self.tools.values():
            yield tool
            
    def run(self, calls: List[ToolCall]) -> List[ToolMessage]:
        return [self.tools[call["name"]].run(call) for call in calls]
    
    async def arun(self, calls: List[ToolCall]) -> List[ToolMessage]:
        return asyncio.gather(
            *[self.tools[call["name"]].arun(call) for call in calls]
        )
        
    def tool(self, f: Callable) -> BaseTool:
        """
        Decorator to convert a function into a BaseTool instance and **bind** it to the current ToolKit.
        The tool can be extracted from the ToolKit by calling get.

        The decorated function can be synchronous, asynchronous, or a generator.
        When using generators, each yielded value produces a streamed event, and the final value
        is displayed to the LLM. Raises ValueError if the function signature is invalid.

        ## Example:
        
            @tool
            def func(inp: InputModel):
                return f"The input was {inp.parameter}"
        """        
        # Inspect the function signature to ensure it has zero or one parameter.
        sig = inspect.signature(f)
        if len(sig.parameters) > 1:
            
            # TODO : Build pydantic model from the function signature
            raise ValueError("Tool function must have zero or one parameter, which must be an instance of BaseModel (or annotated with one).")

        else:
            # Get the unique parameter, if any.
            param = next(iter(sig.parameters.values()), None)

            # If no input model (and no keyword schema options) is provided, try to derive args_schema from the parameter's type.
            if param is None:
                input_model = None
            else:
                if param.annotation is not inspect.Parameter.empty:
                    input_model = param.annotation
                else:  # Parameter has not been annotated
                    raise ValueError(f"Tool function '{f.__name__}' only expects annotated attributes, potentially a single parameter of type BaseModel.")

        # Determine the function type (sync/async, generator, etc.)
        is_async = asyncio.iscoroutinefunction(f)
        is_gen = inspect.isgeneratorfunction(f)
        is_asyncgen = inspect.isasyncgenfunction(f)
        
        # Dynamically create a BaseTool subclass that wraps f.
        class ToolWrapper(BaseTool):
            name: str = f.__name__
            description: str = f.__doc__ or (
                f"This tool was autogenerated by a decorated function. No docstring was included "
                f"in the original function, therefore this tool has no description. Please warn the developer "
                f"that function \"{f.__name__}\" needs a docstring."
            )
            args_schema: type = input_model
                    
            if is_asyncgen:
                async def _astream(self, inp: Optional[pydantic.BaseModel] = None) -> AsyncIterator[str]:
                    stream = f(inp) if inp else f()
                    async for item in stream:
                        yield item

            elif is_gen:
                def _stream(self, inp: Optional[pydantic.BaseModel] = None) -> Iterator[str]:
                    stream = f(inp) if inp else f()
                    for item in stream:
                        yield item

            elif is_async:
                async def _arun(self, inp: Optional[pydantic.BaseModel] = None) -> str:
                    coro = f(inp) if inp else f()
                    return await coro

            else:
                def _run(self, inp: Optional[pydantic.BaseModel] = None) -> str:
                    result = f(inp) if inp else f()
                    return result
        
        # Bind to tool kit and return as a BaseTool instance.
        self.tools[f.__name__] = ToolWrapper()
        
        return self.tools[f.__name__]
